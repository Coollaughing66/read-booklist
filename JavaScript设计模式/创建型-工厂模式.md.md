# 工厂模式

## 简单工厂

小何可轻松了，在使用构造模式造福了整个学院的单身狗之后，突然有一天，小谭来找小何

小谭 : “何总啊，你给我 new 的这个女朋友，我就只知道她的一丢丢信息，但是我不知道她哪的人，你能不能给我 new 一个重庆的小姐姐啊，我喜欢吃辣的妹子 ~”

小谢在旁边听到了，忙着说我也要，我想找一个广州的小姐姐，我比较喜欢吃清淡的妹子！

小何一想，我日，你们两要求还挺多。

完了，前边的女朋友共性都被拆离了，本来规定就只有 ` name``age `、`cup`、`hobby` 的，现在居然还要出生地，哈卖批！

小谭 : “我可以给你发个红包~”

小谢 : “我现在就给你发”

小何一听，干了，有钱能使鬼推磨，不就是多一个字段嘛

```js
function ChongQingGirlFriend(name, age, cup, hobby) {
  this.name = name;
  this.age = age;
  this.cup = cup;
  this.hobby = hobby;
  this.birthplace = "重庆";
}

function GuangZhouGirlFriend(name, age, cup, hobby) {
  this.name = name;
  this.age = age;
  this.cup = cup;
  this.hobby = hobby;
  this.birthplace = "广州";
}
```

哦吼，小何没想到，这特么的，大家一听到可以自定义出生地的女朋友，直接疯狂找他，红包拆到手软

当小何从`重庆`写到`广州`，再从`广州`写到`北京`、`上海`、`成都`... 他突然意思到，这量有点大啊

我得写到啥时候，算了，我用工厂模式吧 ~

```js
function FactoryGirlFriend(name, age, cup, hobby, birthplace) {
  if (birthplace === "chongqing") {
    return new ChongQingGirlFriend(name, age, cup, hobby);
  }
  if (birthplace === "chengdu") {
    return new GuangZhouGirlFriend(name, age, cup, hobby);
  }
  if (birthplace === "beijing") {
    return new BeiJingGirlFriend(name, age, cup, hobby);
  }
  if (birthplace === "shanghai") {
    return new ShangHaiGirlFriend(name, age, cup, hobby);
  }
  ...
}
```

真好，但是我国共划分为 23 个省、5 个自治区、4 个直辖市、2 个特别行政区，要划分再细一些，想想这个 if 语句有些庞大？

<!-- 当场去世 -->

小何心想，我总不能，写 n 个城市女朋友吧，这特么得写到啥时候，于是小何再次封装，此时只需要两个构造器就能完成

```js
function GirlFriend(name, age, cup, hobby, birthplace, eatType) {
  this.name = name;
  this.age = age;
  this.cup = cup;
  this.hobby = hobby;
  this.birthplace = birthplace;
  this.eatType = eatType
}

function FactoryGirlFriend(name, age, cup, hobby, birthplace) {
    let eatType = '';
    switch(birthplace) {
        case 'chongqing':
            eatType = '吃辣，辣的一匹';
            break;
        case 'guangzhou':
            eatType = '吃清淡，喝粥喝茶';
            break;
        case 'fuzhou':
            eatType = '沙县，闽南菜';
            break;
        ....
    }
    return new GirlFriend(name, age, cup, hobby, birthplace, eatType);
}
```

真香啊，工厂模式大法就是好 ~

那么我们该什么时候使用工厂模式?

- 对象或者组件设置涉及到高程度级别的复杂度时。
- 根据我们所在的环境方便的生成不同对象的实体时。
- 在许多共享同一个属性的许多小型对象或组件上工作时。
- 当带有其它仅仅需要满足一种 API 约定(又名鸭式类型)的对象的组合对象工作时.这对于解耦来说是有用的。

可能这里有人会觉得，我直接这么写不也可以？

```js
function FactoryGirlFriend(name, age, cup, hobby, birthplace) {
    this.name = name;
    this.age = age;
    this.cup = cup;
    this.hobby = hobby;
    this.birthplace = birthplace;

    let eatType = '';
    switch(birthplace) {
        case 'chongqing':
            this.eatType = '吃辣，辣的一匹';
            break;
        case 'guangzhou':
            this.eatType = '吃清淡，喝茶喝粥';
            break;
        case 'fuzhou':
            this.eatType = '沙县，闽南菜';
            break;
        ....
    }
}
```

ojbk 啊，你这么写又没错，最终效果是一样的，但是思想是不一样的，所以说设计模式是一种思想 ~
前面说了，设计模式遵循“开放封闭原则”，这里的工厂模式，`GirlFriend`是用来生成女朋友，它的目的就很纯粹，你给我啥，我就给你 new 啥对象，而`FactoryGirlFriend`主要是根据出生地，然后给予这个女朋友一些饮食特性。

这里的`GirlFriend`遵循了“封闭”原则，而`FactoryGirlFriend`遵循“开放”原则，如果只是使用`GirlFriend`，需求一旦改变，`GirlFriend`就会改变。只满足“开放”，不满足“封闭”原则。

## 抽象工厂

在 《JavaScript 设计模式》书中，对抽象工厂是这么解释的，它的目标是以一个通用的目标将一组独立的工厂进行封装.它将一堆对象的实现细节从它们的一般用例中分离。

现在小何开一个淘宝店铺，专门帮人 new 女朋友，大量生产，于是，小何心想，要 new 一个女朋友，需要女朋友的基本特性，还需要打气筒，还需要一些自定义的性质。于是呢，他想到了曾经在某本书上看到的抽象工厂

> 抽象工厂模式创建的是类簇，而非是具体某一个类的实例。抽象工厂模式适用于系统里有多于一个的产品族，而只需要用到某一族的类的场景

```js
function AbstractFactoryGirlFriend() {
    // 提供女朋友基本特性
    baseFeature() {
        // 需要通过prototype重写
    }

    // 提供打气筒
    inflator() {
        // 需要通过prototype重写
    }

    // 提供自定义
    customize() {
        // 需要通过prototype重写
    }
}
```

> 这里为什么需要重写，是因为抽象工厂是通过类的抽象，使得业务适用于一个产品类簇的创建，而不负责某一类产品的实例。

> 也就是说，如果继承的子类中没有覆写该方法而调用，就会抛出错误。比如下边的代码👇

```js
const AbstractFactoryGirlFriend = () {}

AbstractFactoryGirlFriend.prototype.baseFeature = function() {
    return new Error('抽象方法不能调用')
}
```

ok，回到主题，这时候，具体工厂继承抽象工厂，你要知道，抽象工厂不干事的，它只是用于声明最终目标产品的共性，真正干事的就具体工厂。

比如此时此刻，小何同学想生成一类是`BeautifulGirl`, 打气筒用的是中国制造的女朋友

```js
const SpecificGirl = new AbstractFactoryGirlFriend()
SpecificGirl.prototype.baseFeature = function() {
  // 提供漂亮美眉实例
  return new GirlFriend()
}
SpecificGirl.prototype.inflator = function() {
  // 提供中国制造打气筒实例
  return new MakeInChinaInflator()
}
SpecificGirl.prototype.customize = function() {
  // 提供漂亮妹妹特殊自定义实例
  return new MakeInChinaInflator()
}
```
也就是说，我们要生成一个 **1.打气筒用的是中国制造**、**2.基本特性**、**3.特殊类型是BeautifulGirl**的漂亮美眉，就需要调用这三个构造函数: 

- baseFeature()

- inflator()

- customize()

像这些构造函数，都是用来生成实例的，而通过`new SpecificGirl()`出来的实例，就是我们的具体产品类。比如说，你想生成一个 `SexyGirl`，打气筒是来自法国进口的，他们都是女朋友，对吧，都有着基本的特性，都是用打气筒的。因此，可以用一个`抽象产品类`来声名

```js
// 基本特性抽象产品类
function AbstractProductGirlFriend() {
    initBaseFeature() {
        // 需要重写，我只是抽象的
    }
}

const BeautifulGirl = new AbstractProductGirlFriend()
BeautifulGirl.prototype.initBaseFeature = function() {
    console.log('我是漂亮美眉')
    console.log('我的基本特性是: ....')
}
```

```js
// 打气筒抽象产品类
function AbstractProductInflator() {
    inflator() {
        // 需要重写，我只是抽象的
    }
}

const BeautifulInflator = new AbstractProductInflator()
BeautifulInflator.prototype.inflator = function() {
    console.log('我是漂亮美眉')
    console.log('我的打气筒是来自: 中国制造')
}
```

```js
// 特殊自定义抽象产品类
function AbstractProductCustomize() {
    inflator() {
        // 需要重写，我只是抽象的
    }
}

const BeautifulCustomize = new AbstractProductCustomize()
BeautifulCustomize.prototype.customize = function() {
    console.log('我是漂亮美眉')
    console.log('我的特殊自定义是: 爱吃辣，喜欢机车，喜欢极限运动')
}
```

大功告成，这时候来个人找小何，小何只需要这样操作就好了

```js
// 小谭的女朋友，来自重庆，使用欧洲
const myPhone = new FakeStarFactory()
// 让它拥有操作系统
const myOS = myPhone.createOS()
// 让它拥有硬件
const myHardWare = myPhone.createHardWare()
// 启动操作系统(输出‘我会用安卓的方式去操作硬件’)
myOS.controlHardWare()
// 唤醒硬件(输出‘我会用高通的方式去运转’)
myHardWare.operateByOrder()
```